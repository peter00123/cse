<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Document</title>
</head>
<style>
    body{
        margin: 20px;
    }
    h1{font-size: 25 px;
    }
    h2{font-size: 15px;}
    section{
        display: flex;
        flex-wrap: wrap;
    }
    .sec1{
        margin: 10px;
    }
</style>
<body>
    <section>
    <div class="sec1">
    <div>
        <h1>peter</h1>
        <h2>import java.util.Arrays; <br>

            public class FloydWarshall {<br>
                <br>
                final static int INF = 99999;<br>
                <br>
                // A utility function to print the solution matrix<br>
                void printSolution(int dist[][], int V) {<br>
                    System.out.println("The following matrix shows the shortest distances between every pair of vertices:");<br>
                    for (int i = 0; i < V; ++i) {<br>
                        for (int j = 0; j < V; ++j) {<br>
                            if (dist[i][j] == INF) {<br>
                                System.out.print("INF ");<br>
                            } else {<br>
                                System.out.print(dist[i][j] + "   ");<br>
                            }<br>
                        }<br>
                        System.out.println();<br>
                    }<br>
                }<br>
                <br>
                // All-pairs shortest path function using Floyd Warshall algorithm<br>
                void floydWarshall(int graph[][], int V) {<br>
                    int dist[][] = new int[V][V];<br>
                    <br>
                    // Initialize the solution matrix same as input graph matrix<br>
                    for (int i = 0; i < V; i++) {<br>
                        for (int j = 0; j < V; j++) {<br>
                            dist[i][j] = graph[i][j];<br>
                        }<br>
                    }<br>
                    <br>
                    // Adding vertices individually<br>
                    for (int k = 0; k < V; k++) {<br>
                        for (int i = 0; i < V; i++) {<br>
                            for (int j = 0; j < V; j++) {<br>
                                if (dist[i][k] + dist[k][j] < dist[i][j]) {<br>
                                    dist[i][j] = dist[i][k] + dist[k][j];<br>
                                }<br>
                            }<br>
                        }<br>
                    }<br>
                    
                    // Print the shortest distance matrix<br>
                    printSolution(dist, V);<br>
                }<br>
                
                public static void main(String[] args) {<br>
                    FloydWarshall fw = new FloydWarshall();<br>
                    <br>
                    int graph[][] = {<br>
                        {0, 5, INF, 10},<br>
                        {INF, 0, 3, INF},<br>
                        {INF, INF, 0, 1},<br>
                        {INF, INF, INF, 0}<br>
                    };<br>
                    <br>
                    int V = graph.length;<br>
                    <br>
                    fw.floydWarshall(graph, V);<br>
                }<br>
            }</h2>
    </div>
    <br>

    <div>
        <h1>kow</h1>
        <h2>
        public class NaiveStringMatching {<br>

            // Function to implement the naive string matching algorithm<br>
            public static void naiveSearch(String pattern, String text) {<br>
                int M = pattern.length();<br>
                int N = text.length();<br>
                <br>
                // Slide the pattern one by one<br>
                for (int i = 0; i <= N - M; i++) {<br>
                    int j;<br>
        
                    // Check for pattern match<br>
                    for (j = 0; j < M; j++) {<br>
                        if (text.charAt(i + j) != pattern.charAt(j)) {<br>
                            break;<br>
                        }<br>
                    }<br>
                    <br>
                    // If the pattern is found, j will be equal to M<br>
                    if (j == M) {<br>
                        System.out.println("Pattern found at index " + i);<br>
                    }<br>
                }<br>
            }<br>
        
            public static void main(String[] args) {<br>
                String text = "AABAACAADAABAABA";<br>
                String pattern = "AABA";<br>
        
                System.out.println("Text: " + text);<br>
                System.out.println("Pattern: " + pattern);<br>
                <br>
                naiveSearch(pattern, text);<br>
            }<br>
        }<br>
    </h2>
    </div>
    <div>
        <h1>inb</h1>
        <h2>
            public class RecursiveBinarySearch {<br>

                // Recursive binary search function<br>
                public static int binarySearch(int[] arr, int left, int right, int x) {<br>
                    if (right >= left) {<br>
                        int mid = left + (right - left) / 2;<br>
                        <br>
                        // If the element is present at the middle itself<br>
                        if (arr[mid] == x) {<br>
                            return mid;<br>
                        }<br>
            
                        // If the element is smaller than mid, it can only be in the left subarray<br>
                        if (arr[mid] > x) {<br>
                            return binarySearch(arr, left, mid - 1, x);<br>
                        }<br>
            
                        // Else the element can only be in the right subarray<br>
                        return binarySearch(arr, mid + 1, right, x);<br>
                    }<br>
                    <br>
                    // If the element is not present in the array<br>
                    return -1;<br>
                }<br>
            
                public static void main(String[] args) {<br>
                    int[] list = {1, 5, 6, 7, 9, 12, 15, 26, 28, 35, 39};<br>
                    int[] searchKeys = {7, 15, 39};<br>
            
                    for (int key : searchKeys) {<br>
                        int result = binarySearch(list, 0, list.length - 1, key);<br>
                        if (result == -1) {<br>
                            System.out.println("Element " + key + " not found in the list.");<br>
                        } else {<br>
                            System.out.println("Element " + key + " found at index " + result + ".");<br>
                        }<br>
                    }<br>
            
                    // Calculating and printing time complexity<br>
                    System.out.println("\nTime Complexity:");<br>
                    for (int key : searchKeys) {<br>
                        int complexity = calculateTimeComplexity(list.length);<br><br>
                        System.out.println("Element " + key + " -> O(" + complexity + ")");<br>
                    }<br>
                }<br>
            
                // Function to calculate the time complexity of binary search<br>
                public static int calculateTimeComplexity(int n) {<br>
                    return (int) (Math.log(n) / Math.log(2)) + 1; // +1 to account for ceiling effect of log2(n)<br>
                }<br>
            }<br>
        </h2>
    </div>
    </div>
    <div class="sec1">
    <div>
        <h1>jeg</h1>
        <h2>import java.util.Arrays;<br>
            public class HeapSort <br>
            {<br>
                public static void main(String[] args) {<br>
                    int[] arr = {12, 7, 10, 25}; // Example array, replace with desired size<br>
                    heapSort(arr); System.out.println(Arrays.toString(arr));<br>
                }<br>
                static void heapSort(int[] arr) <br>
            {<br>
                    for (int i = arr.length / 2 - 1; i >= 0; i--)    <br>  heapify(arr, arr.length, i);
                    for (int i = arr.length - 1; i >= 0; i--) <br>
            {<br>
            int temp = arr[0];<br>
             arr[0] = arr[i]; <br>
            arr[i] = temp; <br>
            heapify(arr, i, 0);<br>
            }<br>
                }<br>
                static void heapify(int[] arr, int n, int i) <br>
            {<br>
                    int largest = i, l = 2 * i + 1, r = 2 * i + 2; <br>
            if (l < n && arr[l] > arr[largest]) largest = l;<br>
             if (r < n && arr[r] > arr[largest]) largest = r;<br>
                    if (largest != i)<br>
             {<br>
            int swap = arr[i]; <br>
            arr[i] = arr[largest]; <br>
            arr[largest] = swap; <br>
            heapify(arr, n, largest);}<br>
                }<br>
            } </h2>
    </div>
    <div>
        <h1>mani</h1>
 <br>       public class SimpleTSP {<br>
 <br>           public static void main(String[] args) {
 <br>               int[][] dist = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};
 <br>               int minDist = Integer.MAX_VALUE;
 <br>               for (int i = 0; i < 24; i++) {  // There are 4! = 24 permutations
 <br>                   int d = dist[i % 4][(i / 1) % 4] + dist[(i / 1) % 4][(i / 2) % 4] + dist[(i / 2) % 4][(i / 3) % 4] + dist[(i / 3) % 4][(i / 4) % 4];
 <br>                   minDist = Math.min(minDist, d);
 <br>               }
 <br>               System.out.println("Minimum Distance: " + minDist);
 <br>           }
 <br>       }
   </div>

   <div>
    <h1>aka</h1>
    <h2>
 <br>       public class InsertionSortExample {
<br>
 <br>           public static void main(String[] args) {
 <br>               // Define the array to be sorted
 <br>               int[] array = {12, 45, 78, 96, 56, 77, 51, 8, 104, 96};
 <br>       
 <br>               // Perform insertion sort
 <br>               insertionSort(array);
 <br>       
 <br>               // Print the sorted array
 <br>               System.out.println("Sorted array:");
 <br>               for (int num : array) {
 <br>                   System.out.print(num + " ");
 <br>               }
 <br>           }
 <br>       
 <br>           // Method to perform insertion sort
 <br>           public static void insertionSort(int[] array) {
 <br>               int n = array.length;
 <br>               for (int i = 1; i < n; i++) {
 <br>                   int key = array[i];
 <br>                   int j = i - 1;
 <br>       
 <br>                   // Move elements of array[0..i-1], that are greater than key,
 <br>                   // to one position ahead of their current position
 <br>                   while (j >= 0 && array[j] > key) {
 <br>                       array[j + 1] = array[j];
 <br>                       j--;
 <br>                   }
 <br>                   array[j + 1] = key;
 <br>               }
 <br>           }
 <br>       }
    </h2>
   </div></div>
</section>
</body>
</html>
